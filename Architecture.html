<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>StencilStream: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">StencilStream
   &#160;<span id="projectnumber">v2.0.0</span>
   </div>
   <div id="projectbrief">Generic Stencil Simulation Library for FPGAs.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_architecture"></a> </p>
<h2><a class="anchor" id="terms"></a>
Terminology</h2>
<p>First, we have to lay down some terminology used in StencilStream:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Word   </th><th class="markdownTableHeadNone">Definition    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">static   </td><td class="markdownTableBodyNone">defined at compile time, part of the design    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">dynamic   </td><td class="markdownTableBodyNone">defined at runtime, part of the payload data    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Cell   </td><td class="markdownTableBodyNone">Fundamental element of StencilStream's architecture. Its type is user-provided and every cell has a value of this type.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Grid   </td><td class="markdownTableBodyNone">A rectangular container of cells with a dynamic, arbitrary size    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Grid width/height   </td><td class="markdownTableBodyNone">The dynamic number of columns/rows in a grid    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Stencil   </td><td class="markdownTableBodyNone">A quadratic container with a central cell and all cells at a <a href="https://en.wikipedia.org/wiki/Chebyshev_distance">Chebyshev distance</a> up to the stencil radius (<a href="https://en.wikipedia.org/wiki/Moore_neighborhood">extended Moore neighborhood</a>)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Stencil radius   </td><td class="markdownTableBodyNone">The static, maximal Chebyshev distance of cells in a stencil to the central cell    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Stencil diameter   </td><td class="markdownTableBodyNone"><code>2 * stencil_radius + 1</code>, the width and height of the stencil    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Tile   </td><td class="markdownTableBodyNone">A rectangular container of cells with a static size    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tile width/height   </td><td class="markdownTableBodyNone">The number of columns/rows in a tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Transitition function   </td><td class="markdownTableBodyNone">A function that maps a stencil (and additional information) to the next generation of the stencil's central cell    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Tile Halo   </td><td class="markdownTableBodyNone">Additional cells that are added to a tile to form an input tile    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Grid Halo   </td><td class="markdownTableBodyNone">Cells outside of the user-defined grid   </td></tr>
</table>
<h2><a class="anchor" id="index"></a>
Indexing and Iteration order</h2>
<p>Rectangular containers in StencilStream are always organized in columns and rows. The first index is always the column index and the second index is always the row index. The origin is thought to be in the north-western corner. An example where every grid cell contains it's index:</p>
<div class="fragment"><div class="line">                       North</div>
<div class="line">     -----------------------------------------</div>
<div class="line">     | (0,0) | (1,0) | (2,0) | (3,0) | (4,0) |</div>
<div class="line">     -----------------------------------------</div>
<div class="line">     | (0,1) | (1,1) | (2,1) | (3,1) | (4,1) |</div>
<div class="line">     -----------------------------------------</div>
<div class="line">West | (0,2) | (1,2) | (2,2) | (3,2) | (4,2) | East</div>
<div class="line">     -----------------------------------------</div>
<div class="line">     | (0,3) | (1,3) | (2,3) | (3,3) | (4,3) |</div>
<div class="line">     -----------------------------------------</div>
<div class="line">     | (0,4) | (1,4) | (2,4) | (3,4) | (4,4) |</div>
<div class="line">     -----------------------------------------</div>
<div class="line">                       South</div>
</div><!-- fragment --><p>Iteration over rectangular containers in StencilStream is always column wise, meaning that the row index is moving the fastest. An example of a for loop that iterates over a Grid with <code>grid_width</code> columns and <code>grid_height</code> rows:</p>
<div class="fragment"><div class="line">for (uindex_t c = 0; c &lt; grid_width; c++)</div>
<div class="line">{</div>
<div class="line">    for (uindex_t r = 0; r &lt; grid_height; r++)</div>
<div class="line">    {</div>
<div class="line">        grid[c][r] = ID(c, r);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="model"></a>
Architecture</h2>
<p>The general goal of a stencil execution engine like StencilStream is to calculate a certain generation of a grid of cells where a single generation step of a single cell is computed from cell's neighbourhood (contained in the stencil). This is repeated iteratively over all cells of the grid and for all generations up to the desired generation.</p>
<p>However, the na√Øve approach of storing all cells in a buffer and reading the neihbourhood directly from this buffer doesn't work well for FPGAs. StencilStream therefore uses an approach introduced by <a href="https://dl.acm.org/doi/pdf/10.1145/3174243.3174248">Hamid Reza Zohouri, Artur Podobas and Satoshi Matsuoka</a> that uses a spatially tiled buffer and temporal caching to perform the computations.</p>
<h3><a class="anchor" id="tiles"></a>
Tile-wise computation</h3>
<p>Let's look at the simplest case first: There is a tile and we want to calculate the it's next generation. StencilStream splits up this task into an input kernel, an execution kernel and an output kernel. They communicate via on-chip FIFO pipe and the input kernel receives access to the current generation of the tile while the output kernel receives access to buffers for the next generation of the tile. The input kernel reads the cells from the buffer column-wise (as discussed in <a href="#index">"Indexing and Iteration order"</a>) and sends them to the execution kernel.</p>
<p>The execution kernel has an internal stencil buffer stored in registers and a cache stored in on-chip block memory. This cache has a width of <code>stencil_diameter - 1</code> and is as high as the input buffer. When a new cell arrives from the input kernel, every cell in the stencil buffer is shifted to the north once and the new cell is placed in the south-eastern corner of the stencil buffer. The rest of the southern-most row is filled with cells from the cache. Then, the row in the cache is overriden with all the cells in southern-most row of the stencil buffer, except for the western-most cell in this row. In effect, this means that all cells in this row of the cache are shifted west once and the eastern-most cell in this row is set to the input. The following figure illustrates this:</p>
<p><img src="shifting.svg" alt="" style="pointer-events: none;" class="inline" title="Shifting"/></p>
<p>After these shifts, the stencil buffer contains the correct neighbourhood of a central cell. Then, the transition function is executed and the result is sent to the output kernel. The row counter is increased and the next input is read.</p>
<p>Of course, the input and output of an execution stage do not necessarily have to come from the input or output kernel. StencilStream arranges multiple execution stages into a pipeline. This means that for a given pipeline length of <code>p</code>, the grid is only written to global memory every <code>p</code> generations and since the main loop of the execution kernel is pipelined itself, all of these <code>p</code> generations are calculated in parallel, utilizing the full potential of the FPGA. This long stream of values is also where the name "StencilStream" comes from.</p>
<h3><a class="anchor" id="tiling"></a>
Grid Tiling</h3>
<p>In order to calculate the next generation of a cell, you need it's neighbourhood. This neighbourhood is included in the tile for almost all cells, but not for those on the edge of the tile. This means that in order to calculate the next generation of a tile, cells from neighbouring tiles are needed too. These cells are known as the halo of a tile. Since more cells are needed in the halo for every generation that is computed, the input tile has to contain <code>stencil_radius</code> additional cells in every cardinal direction. This leads us to an input tile with <code>tile_width + 2 * stencil_radius * pipeline_lenth</code> columns and <code>tile_height + 2 * stencil_radius * pipeline_length</code> rows.</p>
<p>The execution kernel described above works on tiles, which have a static size, but the user provides a grid, which has a dynamic size. Therefore, StencilStream needs to partition the grid into tiles. Since every tile also needs parts of neighbouring tiles for their halo, these tiles are partitioned into buffers too. Every tile has four corner buffers, four edge buffers and a core buffer. The following figure illustrates this partition, where the buffer borders are marked in black, tile borders are marked in red and the grid border is marked in yellow:</p>
<p><img src="partition.svg" alt="" style="pointer-events: none;" class="inline" title="Partition"/></p>
<p>Note that the shapes of tiles and their buffers is static, but the number of tiles is dynamic and adapted to contain the whole grid. The input kernel receives access to all buffers of a tile as well as the neighbouring buffers from other tiles.</p>
<h3><a class="anchor" id="halo"></a>
Halo/Edge handling</h3>
<p>The last missing concept is StencilStream's grid halo handling. As one can see in the figure above, there are no neighbouring cells for all cells of the grid: There are no further cells at the northern and western edge of the grid and there are additional cells east and south of the grid. These cells belong to the grid halo and their value depends on the transition function in use. Some transition functions can simply leave those cells undefined and ignore them, some can use a default value and some might require something compldifferent.</p>
<p>StencilStream currently only supports transition functions with a default value, which is a superset of those that ignore missing cells. This default value, also known as halo value, is set in the <code>StencilExecutor</code> and StencilStream guarantees that this halo value will be present whenever a cell outside of a grid is accessed.</p>
<h3><a class="anchor" id="burstalignment"></a>
Burst-aligned buffers</h3>
<p>One last concept of note is the layout of the buffers themselves: The global memory interface of most FPGAs support burst accesses where a specific number of bytes can be read or written in one transaction. Therefore, those interfaces are most efficient when all memory accesses are organizsed in such bursts. StencilStream ensures this by using two-dimensional buffers with the "height" of one memory burst. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
